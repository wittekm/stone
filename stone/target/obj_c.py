from __future__ import absolute_import, division, print_function, unicode_literals

import argparse
import os

from collections import namedtuple
from contextlib import contextmanager

from stone.data_type import (
    Boolean,
    Bytes,
    DataType,
    Float32,
    Float64,
    Int32,
    Int64,
    List,
    String,
    Timestamp,
    UInt32,
    UInt64,
    Void,
    is_boolean_type,
    is_bytes_type,
    is_list_type,
    is_string_type,
    is_struct_type,
    is_timestamp_type,
    is_union_type,
    is_numeric_type,
    is_nullable_type,
    is_tag_ref,
    is_user_defined_type,
    is_void_type,
    unwrap_nullable,
)
from stone.generator import CodeGenerator
from stone.target.obj_c_helpers import (
    fmt_camel_upper,
    fmt_class,
    fmt_func,
    fmt_import,
    fmt_obj,
    fmt_type,
    fmt_var,
    is_ptr_type,
    is_primitive_type,
)


stone_warning = """\
///
/// Auto-generated by Stone, do not modify.
///

"""

# This will be at the top of the generated file.
base = """\
{}\
""".format(stone_warning)


undocumented = '(no description)'


comment_prefix = '/// '


class ObjCBaseGenerator(CodeGenerator):
    """Wrapper class over Stone generator for Obj C logic."""

    @contextmanager
    def block_m(self, class_name, protocol=None):
        with self.block('@implementation {}'.format(class_name), delim=('','@end'), dent=0):
            self.emit()
            yield

    @contextmanager
    def block_h_from_data_type(self, data_type, protocol=None):
        assert is_user_defined_type(data_type), \
            'Expected user-defined type, got %r' % type(data_type)

        if not protocol:
            extensions = []
            if data_type.parent_type and is_struct_type(data_type):
                extensions.append(fmt_class(data_type.parent_type.name))
            else:
                if is_union_type(data_type):
                    # Use a handwritten base class
                    extensions.append('NSObject')
                else:
                    extensions.append('NSObject')

            extend_suffix = ' : {}'.format(', '.join(extensions)) if extensions else ''
        else:
            base = data_type.parent_type.name if (data_type.parent_type and not is_union_type(data_type)) else 'NSObject'
            extend_suffix = ' : {} <{}>'.format(base, ', '.join(protocol))
        with self.block('@interface {}{}'.format(fmt_class(data_type.name), extend_suffix), delim=('','@end'), dent=0):
            self.emit()
            yield

    @contextmanager
    def block_h(self, class_name, protocol=None):
        extensions = ['NSObject']

        if not protocol:
            extend_suffix = ' : {}'.format(', '.join(extensions)) if extensions else ''
        else:
            extend_suffix = ' : NSObject <{}>'.format(protocol)

        with self.block('@interface {}{}'.format(class_name, extend_suffix), delim=('','@end'), dent=0):
            self.emit()
            yield

    @contextmanager
    def block_init(self):
        with self.block('if (self != nil)'):
            yield
        self.emit('return self;')

    @contextmanager
    def block_func(self, func, args=[], return_type='void', class_method=False):
        modifier = '-' if not class_method else '+'
        base_string = '{} ({}){}:{}' if args else '{} ({}){}'
        signature = base_string.format(modifier, return_type, func, args)
        with self.block(signature):
            yield

    def _get_imports_m(self, data_types, default_imports):
        """Emits all necessary implementation file imports for the given Stone data type."""
        if not isinstance(data_types, list):
            data_types = [data_types]

        import_classes = default_imports

        for data_type in data_types:
            import_classes.append(fmt_class(data_type.name))

            if data_type.parent_type:
                import_classes.append(fmt_class(data_type.parent_type.name))

            if is_struct_type(data_type) and data_type.has_enumerated_subtypes():
                for tags, subtype in data_type.get_all_subtypes_with_tags():
                    import_classes.append(fmt_class(subtype.name))

            for field in data_type.all_fields:
                data_type, _ = unwrap_nullable(field.data_type)

                # unpack list
                while is_list_type(data_type):
                    data_type = data_type.data_type

                if is_user_defined_type(data_type):
                    import_classes.append(fmt_class(data_type.name))

        
        if import_classes:
            import_classes = list(set(import_classes))
            import_classes.sort()

        return import_classes

    def _get_imports_h(self, data_types, default_imports):
        """Emits all necessary header file imports for the given Stone data type."""
        if not isinstance(data_types, list):
            data_types = [data_types]

        import_classes = default_imports

        for data_type in data_types:
            import_classes.append(fmt_class(data_type.name))

            for field in data_type.all_fields:
                data_type, _ = unwrap_nullable(field.data_type)

                # unpack list
                while is_list_type(data_type):
                    data_type = data_type.data_type

                if is_user_defined_type(data_type):
                    import_classes.append(fmt_class(data_type.name))

        import_classes = list(set(import_classes))
        import_classes.sort()

        return import_classes

    def _generate_imports_h(self, import_classes):
        import_classes = list(set(import_classes))
        import_classes.sort()

        for import_class in import_classes:
            self.emit('@class {};'.format(import_class))

        if import_classes:
            self.emit()

    def _generate_imports_m(self, import_classes):
        import_classes = list(set(import_classes))
        import_classes.sort()

        for import_class in import_classes:
            self.emit(fmt_import(import_class))

        self.emit()

    def _generate_init_imports_h(self, data_type):
        self.emit('#import <Foundation/Foundation.h>')
        self.emit('#import "StoneSerializers.h"')

        if data_type.parent_type:
            self.emit(fmt_import(fmt_class(data_type.parent_type.name)))

        self.emit()

    def _get_namespace_route_imports(self, namespace):
        result = []

        def _unpack_and_store_data_type(data_type):
            if is_list_type(data_type):
                while is_list_type(data_type):
                    data_type = data_type.data_type
            
            if not is_void_type(data_type):
                result.append(data_type)

        for route in namespace.routes:
            _unpack_and_store_data_type(route.arg_data_type)
            _unpack_and_store_data_type(route.result_data_type)
            _unpack_and_store_data_type(route.error_data_type)

        return result

    def _cstor_name_from_fields(self, fields):
        """Returns an Obj C appropriate name for a constructor based on
        the name of the first argument."""
        if fields:
            return self._cstor_name_from_field(fields[0])
        else:
            return 'init'

    def _cstor_name_from_field(self, field):
        """Returns an Obj C appropriate name for a constructor based on
        the name of the supplied argument."""
        return 'initWith{}'.format(fmt_camel_upper(field.name))

    def _docf(self, tag, val):
        if tag == 'route':
            return fmt_func(val)
        elif tag == 'field':
            if '.' in val:
                cls, field = val.split('.')
                return ('{} in {}'.format(fmt_var(field),
                        fmt_class(cls)))
            else:
                return fmt_var(val)
        elif tag in ('type', 'val', 'link'):
            return val
        else:
            import pdb
            pdb.set_trace()
            return val
